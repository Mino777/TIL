# TIL 220310Queue

## ğŸ”¥í•™ìŠµ ë‚´ìš©

### Queue

- FIFO í˜•íƒœì˜ ìë£Œêµ¬ì¡°

```swift
struct Queue<Element> {
    private var queue = [Element]()

    var isEmpty: Bool {
        return queue.isEmpty
    }

    var count: Int {
        return queue.count
    }

    var front: Element? {
        return queue.first
    }

    mutating func enqueue(_ element: Element) {
        queue.append(element)
    }

    mutating func dequeue() -> Element? {
        isEmpty ? nil : queue.removeFirst()
    }
}
    
var queue = Queue<Int>()
queue.enqueue(10)
queue.enqueue(20)
queue.dequeue()
print(queue)
    
```

- ì´ëŸ¬í•œ ê²½ìš° dequeueì—ì„œ elementë“¤ì´ í•˜ë‚˜ì”© ë‹¹ê²¨ì§€ëŠ” ê³¼ì •ë•Œë¬¸ì— O(n)ì´ ë¨.
- ë”°ë¼ì„œ ì•„ë˜ì™€ ê°™ì´ ê°œì„ ì´ ê°€ëŠ¥
    
```swift
struct Queue<Element> {
    private var queue = [Element?]()
    private var head = 0

    var isEmpty: Bool {
        return count == 0
    }

    var count: Int {
        return queue.count - head
    }

    var front: Element? {
        isEmpty ? nil : queue[head]
    }

    mutating func enqueue(_ element: Element) {
        queue.append(element)
    }

    mutating func dequeue() -> Element? {
        guard head < queue.count, let element = queue[head] else {
            return nil
        }

        queue[head] = nil
        head += 1

        let percentage = Double(head) / Double(queue.count)
        if queue.count > 50 && percentage > 0.25 {
            queue.removeFirst(head)
            head = 0
        }

        return element
    }
}
```
- queue[head]ë¥¼ nilë¡œ ë³€ê²½í•˜ê³ , headë¥¼ ì¦ê°€ì‹œì¼œ í¬ì¸íŠ¸ë¥¼ ì´ë™
- dequeueëœ elementë¥¼ ì ì •í•œ ë•Œì— ì‚­ì œì‹œì¼œì£¼ëŠ” ì‘ì—…ì„ ì¶”ê°€í•´ì„œ ë‚­ë¹„ëœ ê³µê°„ì„ ì œê±°
- ë”°ë¼ì„œ ì´ì „ê³¼ ê°™ì´ dequeueí•  ë•Œ ì•ìœ¼ë¡œ ë‹¹ê²¨ì£¼ëŠ” ì‘ì—…ì´ ì—†ì–´ì§€ë©´ì„œ O(1)ì´ ë¨
---

> - ì°¸ê³ 
>   - [swift-algorithm-club/Queue](https://github.com/Mino777/swift-algorithm-club/tree/master/Queue)
