# *기술면접질문.*

### 바로가기

- [Value Type / Reference Type의 차이](#면접1)
- [Weak, Strong, Unowned](#면접2)

----

## <a name="면접1"></a>Value Type / Reference Type의 차이  *<small><update 21.02.16><small>*

#### Value Type
- Structure, Enumeration, Tuple
- Value Type은 Stack에 저장되어있는 값을 비교
- Value Type은 값을 복사해서 새로운 메모리를 생성하고 Stack에 저장 ( 기존 인스턴스와 개별적인 인스턴스 )
- ==를 사용하여 인스턴스를 비교해야되는 상황 / 독립적인 상태로 각각의 사본을 만들고자하는 상황 / 여러 스레드에서 사용될 데이터일 경우 사용

#### Reference Type
- Class, Closure
- Reference Type은 heap에 저장되어있는 값을 비교 -> 형식에 관계없이 실제 값을 비교
- Reference Type은 Stack에는 이전 주소를 그대로 복사한 새로운 Heap 메모리 주소가 저장되고,   Heap에 인스턴스를 저장. Value Type과 달리 인스턴스에 바로 접근할 수 없고 항상 Stack에 거쳐서 접근.
- ===를 사용하여 인스턴스를 비교하는 상황 / 공유된 상태, 변경이 가능한 상태를 원할경우 사용

---


## <a name="면접2"></a>Weak, Strong, Unowned  *<small><update 21.02.17><small>*

#### Strong (강한참조)
- strong은 객체를 소유하여 레퍼런스 카운트가 증가하는 프로퍼티.
- 어떠한 설정도 없을 때의 디폴트값.
- 값 지정 시점에 리테인 되고 참조가 종료되는 시점에 릴리즈 됨.
- 레퍼런스 카운트를 증가시켜 ARC로 인한 메모리 해제를 피하고 객체를 안전하게 사용하고자 할 때 사용
- Strong Reference Cycle은 클로저 캡처링이나 객체간 서로 참조 등등의 경우 레퍼런스 카운트가 0이 되지 않는 상황이 있을 수 있꼬, 이 때 메모리 누수가 발생할 수 있음.

#### Weak, Unowned
- weak는 객체를 소유하지 않고 주소값만을 가지고 있는 포인터 개념
- weak는 반드시 Opational, 객체가 ARC에 의해 해제가 되면 nil 값이 할당.
- weak의 대표적인 예로는 Delegate 패턴.
- 자신이 참조는 하지만, weak 메모리를 해제시킬 수 있는 권한은 다른 클래스에 있음.
- 대상 객체에 대해 레퍼런스 카운트를 변화시키지 않음. -> 레퍼런스 카운트를 증가시키거나 감소시키지 않음.
- weak와 unowned는 상당히 유사하지만 차이점으로는 타입이 옵셔널이냐 아니냐. -> Swift5+ 부터는 unowned도 옵셔널 타입으로 사용이 가능하지만 일반적으로 weak을 사용
